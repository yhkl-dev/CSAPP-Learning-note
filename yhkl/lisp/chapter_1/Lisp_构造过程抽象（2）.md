sp 构造过程抽象

```
(/ (x / (* y y) + (* 2 y)) 3 )
```



#### 线性的递归和迭代

阶乘函数

```
n! = n x (n - 1) x (n - 2) ... 3 x 2 x 1
```

代码实现

```commonlisp
(defun (factorial n)
	(if (= n 1)
		1
		(* n factorial (- n 1))
	)
)
```

```lisp
(dufun factorial (n)
	(fact-iter 1 1 n)
)

(defun fact-iter (product counter max-count)
	(if (> counter max-count)
		product
		fact-iter ((* counter product )
				  (+ counter 1)
				  max-count
		)
	)
)
```



代换模型揭示出一种先逐步展开而后收缩的形状。

在展开阶段里，这一计算过程构造了一个推迟进行的操作所形成的链条，收缩阶段表现为这些运算的实际执行。这种类型的计算过程由一个推迟执行的运算链条刻画，称为一个**递归计算过程**。

在计算阶乘n!时，推迟执行的乘法链条的长度也就是为保存其轨迹需要保存的信息量，这个长度随着n值而线性增长，就像计算中得步骤数目一样，这样的计算过程称为一个**线性递归过程**

第二个计算过程里并没有任何增长或者收缩，对于任何一个n，在计算过程中得每一步，在我们需要保存轨迹里，所有得东西就是变量product、counter和max-counter，我们称这种过程为一个**迭代计算过程**，一般来说，迭代计算过程就是那种其状态可以用固定数目的状态变量描述的计算过程，而与此同时又存在着一套固定的规则，描述了计算过程在从一个状态到下一个状态转换时，这些变量的更新方式，还有一个（可能的）结束检测，它描述这一计算过程应该终止的条件。在计算n！时，所以许多e计算步骤随着n线性增长，这种过程称为**线性迭代过程**

#### 树形递归

树形递归如斐波那契数列的表示，容易理解但是效率低下，做了非常多的重复计算

#### 增长的阶

不同的计算过程在消耗计算资源的速率上可能存在着巨大差异，描述这种差异的一种方便方式是用**增长的阶**的记法，以便我们理解在输入变大时，某一计算过程所需资源的粗滤情况
